#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TEMPLATE_FILE="$SCRIPT_DIR/lima-template.yaml"
SANDBOX_PREFIX="sandbox-"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${BLUE}▸${NC} $1"; }
log_success() { echo -e "${GREEN}✓${NC} $1"; }
log_warn() { echo -e "${YELLOW}!${NC} $1"; }
log_error() { echo -e "${RED}✗${NC} $1"; }

DEFAULT_MODEL="opus"

usage() {
    cat <<EOF
Claude Sandbox - Isolated development environments

Usage:
    sandbox <path> [options]               Enter a sandbox (creates if needed)
    sandbox <name>                         Attach to existing sandbox by name
    sandbox <name> run <cmd>               Run a command in existing sandbox
    sandbox run <cmd> <path> [options]     Run a command in a sandbox (creates if needed)
    sandbox list                           List all sandboxes
    sandbox stop <name>                    Stop a running sandbox
    sandbox rm <name>                      Delete a sandbox

Options:
    --name, -n <name>                      Custom sandbox name
    --model, -m <model>                    Claude model (default: opus)
    --no-docker                            Disable Docker (leaner VM, 50GB disk)

Examples:
    sandbox ~/Code/myproject              # Creates sandbox with Docker support
    sandbox ~/Code/myproject --no-docker  # Lean sandbox without containers
    sandbox ~/Code/myproject --model sonnet
    sandbox myproject                     # Attach to existing "myproject" sandbox
    sandbox myproject run claude          # Run claude in existing sandbox
    sandbox run claude ~/Code/myproject   # Run claude (creates sandbox if needed)
    sandbox list
    sandbox stop myproject
    sandbox rm myproject

The VM comes with Claude Code and Docker pre-installed. Your codebase is mounted at /workspace.
EOF
}

check_lima() {
    if ! command -v limactl &> /dev/null; then
        log_error "Lima is not installed. Install with: brew install lima"
        exit 1
    fi
}

get_vm_name() {
    echo "${SANDBOX_PREFIX}$1"
}

# Check if a VM exists by name
vm_exists() {
    local vm_name="$1"
    limactl list --json 2>/dev/null | jq -se ".[] | select(.name == \"$vm_name\")" &>/dev/null
}

# Get VM status by name
vm_status() {
    local vm_name="$1"
    limactl list --json 2>/dev/null | jq -rs ".[] | select(.name == \"$vm_name\") | .status"
}

# Ensure model preference is set in settings.json
ensure_model_setting() {
    local model="${1:-$DEFAULT_MODEL}"
    local settings_file="$HOME/.claude/settings.json"

    if [[ -f "$settings_file" ]]; then
        # Update existing file with model setting
        local tmp=$(mktemp)
        jq --arg model "$model" '.model = $model' "$settings_file" > "$tmp" 2>/dev/null && mv "$tmp" "$settings_file"
    else
        # Create new settings file with model
        echo "{\"model\": \"$model\"}" > "$settings_file"
    fi
}

# Sync Claude auth from macOS Keychain to file for Linux VM
sync_claude_auth() {
    local model="${1:-$DEFAULT_MODEL}"
    local creds_file="$HOME/.claude/.credentials.json"
    local config_file="$HOME/.claude.json"

    # Ensure model preference is set (shared via mount)
    ensure_model_setting "$model"

    # Try to extract credentials from macOS Keychain
    local creds
    creds=$(security find-generic-password -s "Claude Code-credentials" -w 2>/dev/null) || return 0

    if [[ -n "$creds" ]]; then
        echo "$creds" > "$creds_file"
        chmod 600 "$creds_file"

        # Also set hasCompletedOnboarding to skip interactive setup
        if [[ -f "$config_file" ]]; then
            # Update existing file
            local tmp=$(mktemp)
            jq '.hasCompletedOnboarding = true' "$config_file" > "$tmp" 2>/dev/null && mv "$tmp" "$config_file"
        else
            # Create new file
            echo '{"hasCompletedOnboarding": true}' > "$config_file"
        fi

        log_success "Synced Claude auth from Keychain"
    fi
}

# Create a new sandbox
create_sandbox() {
    local name="$1"
    local code_path="$2"
    local model="${3:-$DEFAULT_MODEL}"
    local no_docker="${4:-false}"
    local vm_name
    vm_name="$(get_vm_name "$name")"

    # Ensure ~/.claude exists for auth sharing
    if [[ ! -d "$HOME/.claude" ]]; then
        log_info "Creating ~/.claude directory for auth sharing..."
        mkdir -p "$HOME/.claude"
    fi

    # Sync auth from Keychain
    sync_claude_auth "$model"

    if [[ "$no_docker" == "true" ]]; then
        log_info "Creating sandbox '$name' (lean, no Docker) with $code_path mounted..."
    else
        log_info "Creating sandbox '$name' (with Docker) with $code_path mounted..."
    fi

    # Generate config from template
    local tmp_config
    tmp_config=$(mktemp)
    cp "$TEMPLATE_FILE" "$tmp_config"

    # Substitute code path
    sed -i.bak "s|{{CODE_PATH}}|$code_path|g" "$tmp_config"

    # Configure container support
    if [[ "$no_docker" == "true" ]]; then
        # No Docker: 50GB disk, remove Docker provisioning
        sed -i.bak "s|{{DISK_SIZE}}|50GiB|g" "$tmp_config"
        sed -i.bak "s|{{DOCKER_MESSAGE}}||g" "$tmp_config"
        # Remove Docker provisioning section
        sed -i.bak '/#{{DOCKER_PROVISION_START}}/,/#{{DOCKER_PROVISION_END}}/d' "$tmp_config"
    else
        # Docker enabled: 100GB disk, keep Docker provisioning
        sed -i.bak "s|{{DISK_SIZE}}|100GiB|g" "$tmp_config"
        sed -i.bak "s|{{DOCKER_MESSAGE}}|Docker is available for running containers (e.g., wp-env)|g" "$tmp_config"
        # Remove the marker comments but keep the content
        sed -i.bak 's|#{{DOCKER_PROVISION_START}}||g' "$tmp_config"
        sed -i.bak 's|#{{DOCKER_PROVISION_END}}||g' "$tmp_config"
    fi

    # Clean up backup files from sed -i
    rm -f "$tmp_config.bak"

    # Filter Lima's cd errors for all limactl commands
    exec 3>&2 2> >(grep -v "^bash: line 1: cd:" >&3)

    # Create and start the VM
    limactl create --name="$vm_name" "$tmp_config"
    rm "$tmp_config"

    limactl start "$vm_name"

    log_success "Sandbox '$name' created and started!"
    log_info "Installing Claude Code (this may take a moment)..."

    # Install Claude Code (native)
    limactl shell "$vm_name" -- bash -c '
        # Install Claude Code via native installer
        if [ ! -f "$HOME/.local/bin/claude" ]; then
            curl -fsSL https://claude.ai/install.sh | bash
            echo "✓ Claude Code installed"
        fi

        # Install Node.js via nvm (for npm-based tools if needed)
        if ! command -v node &> /dev/null; then
            curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
            nvm install --lts
            echo "✓ Node.js installed"
        fi
    '

    exec 2>&3 3>&-

    log_success "Setup complete!"
}

# Attach to an existing sandbox, optionally running a command
attach_sandbox() {
    local name="$1"
    local cmd="${2:-}"
    local model="${3:-$DEFAULT_MODEL}"
    local vm_name
    vm_name="$(get_vm_name "$name")"

    # Sync auth from Keychain before attaching
    sync_claude_auth "$model"

    # Check status and start if needed
    local status
    status=$(vm_status "$vm_name")

    if [[ "$status" != "Running" ]]; then
        log_info "Starting sandbox '$name'..."
        limactl start "$vm_name"
    fi

    if [[ -n "$cmd" ]]; then
        # Run command (set up paths first)
        log_info "Running in sandbox '$name': $cmd"
        echo ""
        limactl shell --workdir /workspace "$vm_name" -- bash -c "
            export PATH=\"\$HOME/.local/bin:\$PATH\"
            export NVM_DIR=\"\$HOME/.nvm\"
            [ -s \"\$NVM_DIR/nvm.sh\" ] && . \"\$NVM_DIR/nvm.sh\"
            $cmd
        "
    else
        # Interactive shell
        log_info "Entering sandbox '$name' (/workspace)"
        echo ""
        limactl shell --workdir /workspace "$vm_name"
    fi
}

# Main command: enter a sandbox (create if needed, then attach)
cmd_enter() {
    local code_path="${1:-}"
    local name=""
    local model="$DEFAULT_MODEL"
    local no_docker="false"

    if [[ -z "$code_path" ]]; then
        usage
        exit 1
    fi

    # Check if first arg is an existing sandbox name
    local vm_name
    vm_name="$(get_vm_name "$code_path")"
    if vm_exists "$vm_name"; then
        # Check for: sandbox <name> run <cmd>
        if [[ "${2:-}" == "run" ]]; then
            shift 2  # skip name and "run"
            local cmd="$*"
            if [[ -z "$cmd" ]]; then
                log_error "Usage: sandbox <name> run <command>"
                exit 1
            fi
            attach_sandbox "$code_path" "$cmd" "$model"
        else
            # Just attach to existing sandbox
            attach_sandbox "$code_path" "" "$model"
        fi
        return
    fi

    # Not an existing sandbox - parse remaining args for flags
    shift || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name|-n)
                name="${2:-}"
                shift 2
                ;;
            --model|-m)
                model="${2:-}"
                shift 2
                ;;
            --no-docker)
                no_docker="true"
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    # Otherwise treat as a path
    if [[ ! -d "$code_path" ]]; then
        log_error "Path does not exist: $code_path"
        exit 1
    fi
    code_path="$(cd "$code_path" && pwd)"

    # Derive name from directory if not specified
    if [[ -z "$name" ]]; then
        name="$(basename "$code_path")"
    fi

    vm_name="$(get_vm_name "$name")"

    # Create if doesn't exist
    if ! vm_exists "$vm_name"; then
        create_sandbox "$name" "$code_path" "$model" "$no_docker"
    fi

    # Attach (interactive)
    attach_sandbox "$name" "" "$model"
}

# Run a command in a sandbox
cmd_run() {
    local cmd="${1:-}"
    local code_path="${2:-}"
    local name=""
    local model="$DEFAULT_MODEL"
    local no_docker="false"

    if [[ -z "$cmd" || -z "$code_path" ]]; then
        log_error "Usage: sandbox run <command> <path> [--name <name>] [--model <model>]"
        exit 1
    fi

    # Parse remaining args for flags
    shift 2 || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name|-n)
                name="${2:-}"
                shift 2
                ;;
            --model|-m)
                model="${2:-}"
                shift 2
                ;;
            --no-docker)
                no_docker="true"
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    # Resolve to absolute path
    if [[ ! -d "$code_path" ]]; then
        log_error "Path does not exist: $code_path"
        exit 1
    fi
    code_path="$(cd "$code_path" && pwd)"

    # Derive name from directory if not specified
    if [[ -z "$name" ]]; then
        name="$(basename "$code_path")"
    fi

    local vm_name
    vm_name="$(get_vm_name "$name")"

    # Create if doesn't exist
    if ! vm_exists "$vm_name"; then
        create_sandbox "$name" "$code_path" "$model" "$no_docker"
    fi

    # Run command
    attach_sandbox "$name" "$cmd" "$model"
}

cmd_list() {
    log_info "Sandboxes:"
    echo ""

    local found=false
    while IFS= read -r line; do
        local vm_name status
        vm_name=$(echo "$line" | jq -r '.name')
        status=$(echo "$line" | jq -r '.status')

        if [[ "$vm_name" == ${SANDBOX_PREFIX}* ]]; then
            found=true
            local display_name="${vm_name#$SANDBOX_PREFIX}"

            case "$status" in
                Running)
                    echo -e "  ${GREEN}●${NC} $display_name (running)"
                    ;;
                Stopped)
                    echo -e "  ${YELLOW}○${NC} $display_name (stopped)"
                    ;;
                *)
                    echo -e "  ${RED}○${NC} $display_name ($status)"
                    ;;
            esac
        fi
    done < <(limactl list --json 2>/dev/null | jq -sc '.[]')

    if [[ "$found" == false ]]; then
        echo "  No sandboxes found. Create one with: sandbox ~/path/to/code"
    fi
    echo ""
}

cmd_stop() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: sandbox stop <name>"
        exit 1
    fi

    local vm_name
    vm_name="$(get_vm_name "$name")"

    log_info "Stopping sandbox '$name'..."
    limactl stop "$vm_name"
    log_success "Sandbox '$name' stopped."
}

cmd_delete() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: sandbox rm <name>"
        exit 1
    fi

    local vm_name
    vm_name="$(get_vm_name "$name")"

    log_warn "This will permanently delete sandbox '$name'."
    read -p "Are you sure? [y/N] " -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        limactl delete --force "$vm_name"
        log_success "Sandbox '$name' deleted."
    else
        log_info "Cancelled."
    fi
}

# Main
check_lima

case "${1:-}" in
    run)
        shift
        cmd_run "$@"
        ;;
    list|ls)
        cmd_list
        ;;
    stop)
        cmd_stop "${2:-}"
        ;;
    rm|delete)
        cmd_delete "${2:-}"
        ;;
    -h|--help|help)
        usage
        ;;
    "")
        usage
        ;;
    *)
        # Default: treat as path and enter interactive shell
        cmd_enter "$@"
        ;;
esac
