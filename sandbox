#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TEMPLATE_FILE="$SCRIPT_DIR/lima-template.yaml"
SANDBOX_PREFIX="sandbox-"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${BLUE}▸${NC} $1"; }
log_success() { echo -e "${GREEN}✓${NC} $1"; }
log_warn() { echo -e "${YELLOW}!${NC} $1"; }
log_error() { echo -e "${RED}✗${NC} $1"; }

usage() {
    cat <<EOF
Claude Sandbox - Isolated development environments

Usage:
    sandbox <path> [--name <name>]         Enter a sandbox (creates if needed)
    sandbox run <cmd> <path> [--name <n>]  Run a command in a sandbox
    sandbox list                           List all sandboxes
    sandbox stop <name>                    Stop a running sandbox
    sandbox rm <name>                      Delete a sandbox

Examples:
    sandbox ~/Code/myproject              # Creates and enters sandbox "myproject"
    sandbox run claude ~/Code/myproject   # Run claude in the sandbox
    sandbox run "npm test" ~/Code/myproject
    sandbox list
    sandbox stop myproject
    sandbox rm myproject

The VM comes with Claude Code pre-installed and your codebase mounted at /workspace.
EOF
}

check_lima() {
    if ! command -v limactl &> /dev/null; then
        log_error "Lima is not installed. Install with: brew install lima"
        exit 1
    fi
}

get_vm_name() {
    echo "${SANDBOX_PREFIX}$1"
}

# Check if a VM exists by name
vm_exists() {
    local vm_name="$1"
    limactl list --json 2>/dev/null | jq -se ".[] | select(.name == \"$vm_name\")" &>/dev/null
}

# Get VM status by name
vm_status() {
    local vm_name="$1"
    limactl list --json 2>/dev/null | jq -rs ".[] | select(.name == \"$vm_name\") | .status"
}

# Sync Claude auth from macOS Keychain to file for Linux VM
sync_claude_auth() {
    local creds_file="$HOME/.claude/.credentials.json"

    # Try to extract credentials from macOS Keychain
    local creds
    creds=$(security find-generic-password -s "Claude Code-credentials" -w 2>/dev/null) || return 0

    if [[ -n "$creds" ]]; then
        echo "$creds" > "$creds_file"
        chmod 600 "$creds_file"
        log_success "Synced Claude auth from Keychain"
    fi
}

# Create a new sandbox
create_sandbox() {
    local name="$1"
    local code_path="$2"
    local vm_name
    vm_name="$(get_vm_name "$name")"

    # Ensure ~/.claude exists for auth sharing
    if [[ ! -d "$HOME/.claude" ]]; then
        log_info "Creating ~/.claude directory for auth sharing..."
        mkdir -p "$HOME/.claude"
    fi

    # Sync auth from Keychain
    sync_claude_auth

    log_info "Creating sandbox '$name' with $code_path mounted..."

    # Generate config from template with the code path substituted
    local tmp_config
    tmp_config=$(mktemp)
    sed "s|{{CODE_PATH}}|$code_path|g" "$TEMPLATE_FILE" > "$tmp_config"

    # Create and start the VM
    limactl create --name="$vm_name" "$tmp_config"
    rm "$tmp_config"

    limactl start "$vm_name"

    log_success "Sandbox '$name' created and started!"
    log_info "Installing Claude Code (this may take a moment)..."

    # Install Claude Code (native)
    limactl shell "$vm_name" -- bash -c '
        # Install Claude Code via native installer
        if [ ! -f "$HOME/.local/bin/claude" ]; then
            curl -fsSL https://claude.ai/install.sh | bash
            echo "✓ Claude Code installed"
        fi

        # Install Node.js via nvm (for npm-based tools if needed)
        if ! command -v node &> /dev/null; then
            curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
            nvm install --lts
            echo "✓ Node.js installed"
        fi
    '

    log_success "Setup complete!"
}

# Attach to an existing sandbox, optionally running a command
attach_sandbox() {
    local name="$1"
    local cmd="${2:-}"
    local vm_name
    vm_name="$(get_vm_name "$name")"

    # Sync auth from Keychain before attaching
    sync_claude_auth

    # Check status and start if needed
    local status
    status=$(vm_status "$vm_name")

    if [[ "$status" != "Running" ]]; then
        log_info "Starting sandbox '$name'..."
        limactl start "$vm_name"
    fi

    if [[ -n "$cmd" ]]; then
        # Run command (set up paths first)
        log_info "Running in sandbox '$name': $cmd"
        echo ""
        limactl shell "$vm_name" -- bash -c "
            cd /workspace
            export PATH=\"\$HOME/.local/bin:\$PATH\"
            export NVM_DIR=\"\$HOME/.nvm\"
            [ -s \"\$NVM_DIR/nvm.sh\" ] && . \"\$NVM_DIR/nvm.sh\"
            $cmd
        "
    else
        # Interactive shell (login shell to source profile)
        log_info "Entering sandbox '$name' (/workspace)"
        echo ""
        limactl shell "$vm_name" -- bash -lc "cd /workspace && exec bash -l"
    fi
}

# Main command: enter a sandbox (create if needed, then attach)
cmd_enter() {
    local code_path="${1:-}"
    local name=""

    # Parse --name flag
    shift || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name|-n)
                name="${2:-}"
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    if [[ -z "$code_path" ]]; then
        usage
        exit 1
    fi

    # Resolve to absolute path
    if [[ ! -d "$code_path" ]]; then
        log_error "Path does not exist: $code_path"
        exit 1
    fi
    code_path="$(cd "$code_path" && pwd)"

    # Derive name from directory if not specified
    if [[ -z "$name" ]]; then
        name="$(basename "$code_path")"
    fi

    local vm_name
    vm_name="$(get_vm_name "$name")"

    # Create if doesn't exist
    if ! vm_exists "$vm_name"; then
        create_sandbox "$name" "$code_path"
    fi

    # Attach (interactive)
    attach_sandbox "$name"
}

# Run a command in a sandbox
cmd_run() {
    local cmd="${1:-}"
    local code_path="${2:-}"
    local name=""

    if [[ -z "$cmd" || -z "$code_path" ]]; then
        log_error "Usage: sandbox run <command> <path> [--name <name>]"
        exit 1
    fi

    # Parse remaining args for --name flag
    shift 2 || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name|-n)
                name="${2:-}"
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    # Resolve to absolute path
    if [[ ! -d "$code_path" ]]; then
        log_error "Path does not exist: $code_path"
        exit 1
    fi
    code_path="$(cd "$code_path" && pwd)"

    # Derive name from directory if not specified
    if [[ -z "$name" ]]; then
        name="$(basename "$code_path")"
    fi

    local vm_name
    vm_name="$(get_vm_name "$name")"

    # Create if doesn't exist
    if ! vm_exists "$vm_name"; then
        create_sandbox "$name" "$code_path"
    fi

    # Run command
    attach_sandbox "$name" "$cmd"
}

cmd_list() {
    log_info "Sandboxes:"
    echo ""

    local found=false
    while IFS= read -r line; do
        local vm_name status
        vm_name=$(echo "$line" | jq -r '.name')
        status=$(echo "$line" | jq -r '.status')

        if [[ "$vm_name" == ${SANDBOX_PREFIX}* ]]; then
            found=true
            local display_name="${vm_name#$SANDBOX_PREFIX}"

            case "$status" in
                Running)
                    echo -e "  ${GREEN}●${NC} $display_name (running)"
                    ;;
                Stopped)
                    echo -e "  ${YELLOW}○${NC} $display_name (stopped)"
                    ;;
                *)
                    echo -e "  ${RED}○${NC} $display_name ($status)"
                    ;;
            esac
        fi
    done < <(limactl list --json 2>/dev/null | jq -sc '.[]')

    if [[ "$found" == false ]]; then
        echo "  No sandboxes found. Create one with: sandbox ~/path/to/code"
    fi
    echo ""
}

cmd_stop() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: sandbox stop <name>"
        exit 1
    fi

    local vm_name
    vm_name="$(get_vm_name "$name")"

    log_info "Stopping sandbox '$name'..."
    limactl stop "$vm_name"
    log_success "Sandbox '$name' stopped."
}

cmd_delete() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: sandbox rm <name>"
        exit 1
    fi

    local vm_name
    vm_name="$(get_vm_name "$name")"

    log_warn "This will permanently delete sandbox '$name'."
    read -p "Are you sure? [y/N] " -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        limactl delete --force "$vm_name"
        log_success "Sandbox '$name' deleted."
    else
        log_info "Cancelled."
    fi
}

# Main
check_lima

case "${1:-}" in
    run)
        shift
        cmd_run "$@"
        ;;
    list|ls)
        cmd_list
        ;;
    stop)
        cmd_stop "${2:-}"
        ;;
    rm|delete)
        cmd_delete "${2:-}"
        ;;
    -h|--help|help)
        usage
        ;;
    "")
        usage
        ;;
    *)
        # Default: treat as path and enter interactive shell
        cmd_enter "$@"
        ;;
esac
